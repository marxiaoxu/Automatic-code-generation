var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"xusiming","ref":false,"files":[{"name":"xusiming.c","type":"source","group":"model","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: xusiming.c\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"xusiming.h\"\r\n#include \"xusiming_private.h\"\r\n#include \"rtwtypes.h\"\r\n#include <math.h>\r\n#include \"rt_nonfinite.h\"\r\n#include \"zero_crossing_types.h\"\r\n\r\n/* Block signals (default storage) */\r\nB_xusiming xusiming_B;\r\n\r\n/* Block states (default storage) */\r\nDW_xusiming xusiming_DW;\r\n\r\n/* Previous zero-crossings (trigger) states */\r\nPrevZCX_xusiming xusiming_PrevZCX;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_xusiming xusiming_M_;\r\nRT_MODEL_xusiming *const xusiming_M = &xusiming_M_;\r\nvoid xusiming_ASYNC5(int controlPortIdx)\r\n{\r\n  xusiming_Subsystem5();\r\n}\r\n\r\n/* Output and update for function-call system: '<Root>/Subsystem5' */\r\nvoid xusiming_Subsystem5(void)\r\n{\r\n  {\r\n    CAN_RxHeaderTypeDef rxHeader = { 0 };\r\n\r\n    uint8_t rxData[8] = { 0 };\r\n\r\n    /* Get received frame. */\r\n    if (HAL_CAN_GetRxMessage(&hcan1, CAN_RX_FIFO0, &rxHeader, &rxData[0])!=\r\n        HAL_OK) {\r\n      xusiming_B.CAN_Read_Data_o1 = (uint8_t)0;\r\n    } else {\r\n      /* Update Read_Data:output 0: ready. */\r\n      xusiming_B.CAN_Read_Data_o1 = (uint8_t)1;\r\n\r\n      {\r\n        /* Update output 2. */\r\n        xusiming_B.CAN_Read_Data_o2 = (uint8_t)rxHeader.IDE;\r\n\r\n        /* Update output 3. */\r\n        xusiming_B.CAN_Read_Data_o4 = (uint8_t)rxHeader.RTR;\r\n\r\n        /* Update output 4. */\r\n        xusiming_B.CAN_Read_Data_o5 = (uint16_t)rxHeader.DLC;\r\n\r\n        /* Update output 5. */\r\n        memcpy(&xusiming_B.CAN_Read_Data_o6[0],&rxData[0],(size_t)rxHeader.DLC);\r\n        if (rxHeader.IDE == CAN_ID_STD) {\r\n          xusiming_B.CAN_Read_Data_o3 = (uint32_t)rxHeader.StdId;\r\n        } else {\r\n          xusiming_B.CAN_Read_Data_o3 = (uint32_t)rxHeader.ExtId;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (xusiming_B.CAN_Read_Data_o1 == 1) {\r\n    if (xusiming_B.CAN_Read_Data_o6[0] == 1) {\r\n      xusiming_DW.execpt++;\r\n    }\r\n\r\n    if (xusiming_B.CAN_Read_Data_o6[0] == 2) {\r\n      xusiming_DW.execpt--;\r\n    }\r\n\r\n    if (xusiming_B.CAN_Read_Data_o6[0] == 3) {\r\n      xusiming_DW.ki += 0.1;\r\n    }\r\n\r\n    if (xusiming_B.CAN_Read_Data_o6[0] == 4) {\r\n      xusiming_DW.ki -= 0.1;\r\n    }\r\n\r\n    if (xusiming_B.CAN_Read_Data_o6[0] == 5) {\r\n      xusiming_DW.kp += 0.1;\r\n    }\r\n\r\n    if (xusiming_B.CAN_Read_Data_o6[0] == 6) {\r\n      xusiming_DW.kp -= 0.1;\r\n    }\r\n  }\r\n}\r\n\r\n/* Model step function */\r\nvoid xusiming_step(void)\r\n{\r\n  ZCEventType zcEvent;\r\n\r\n  {\r\n    /* Get number of pending message for CAN1 CAN_RX_FIFO0 */\r\n    xusiming_B.CAN_NbPendingMsg = HAL_CAN_GetRxFifoFillLevel(&hcan1,\r\n      CAN_RX_FIFO0);\r\n  }\r\n\r\n  {\r\n    xusiming_B.GPIO_Read = (boolean_T)HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_3);\r\n  }\r\n\r\n  {\r\n    xusiming_B.GPIO_Read1 = (boolean_T)HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_4);\r\n  }\r\n\r\n  zcEvent = rt_ZCFcn(FALLING_ZERO_CROSSING,&xusiming_PrevZCX.Subsystem4_Trig_ZCE,\r\n                     (xusiming_B.GPIO_Read1));\r\n  if (zcEvent != NO_ZCEVENT) {\r\n    {\r\n      HAL_GPIO_TogglePin(GPIOE, GPIO_PIN_13);\r\n    }\r\n\r\n    {\r\n      HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_7);\r\n    }\r\n  }\r\n\r\n  {\r\n  }\r\n\r\n  {\r\n  }\r\n\r\n  /* Update absolute time for base rate */\r\n  /* The \"clockTick0\" counts the number of times the code of this task has\r\n   * been executed. The resolution of this integer timer is 0.001, which is the step size\r\n   * of the task. Size of \"clockTick0\" ensures timer will not overflow during the\r\n   * application lifespan selected.\r\n   */\r\n  xusiming_M->Timing.clockTick0++;\r\n  switch (xusiming_M->Timing.rtmDbBufReadBuf3) {\r\n   case 0:\r\n    xusiming_M->Timing.rtmDbBufWriteBuf3 = 1;\r\n    break;\r\n\r\n   case 1:\r\n    xusiming_M->Timing.rtmDbBufWriteBuf3 = 0;\r\n    break;\r\n\r\n   default:\r\n    xusiming_M->Timing.rtmDbBufWriteBuf3 =\r\n      !xusiming_M->Timing.rtmDbBufLastBufWr3;\r\n    break;\r\n  }\r\n\r\n  xusiming_M->Timing.rtmDbBufClockTick3[xusiming_M->Timing.rtmDbBufWriteBuf3] =\r\n    xusiming_M->Timing.clockTick0;\r\n  xusiming_M->Timing.rtmDbBufLastBufWr3 = xusiming_M->Timing.rtmDbBufWriteBuf3;\r\n  xusiming_M->Timing.rtmDbBufWriteBuf3 = 0xFF;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid xusiming_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n  xusiming_M->Timing.rtmDbBufReadBuf3 = 0xFF;\r\n  xusiming_M->Timing.rtmDbBufWriteBuf3 = 0xFF;\r\n  xusiming_M->Timing.rtmDbBufLastBufWr3 = 0;\r\n\r\n  {\r\n    /* user code (Start function Header) */\r\n    {\r\n      /* TIM1 initialization. */\r\n      /* Store TIM1 informations and its handler. */\r\n      G_TIM_Conf[G_TIM_Count] = &TIM1_Conf;\r\n      G_TIM_Handler[G_TIM_Count] = &htim1;\r\n      G_TIM_Count++;\r\n\r\n      /* Store TIM information. */\r\n      TIM1_Conf.TIM_Prescaler = 167;\r\n      TIM1_Conf.TIM_APBClock = 168000000;\r\n      TIM1_Conf.TIM_ARR = 1000 - 1;\r\n      TIM1_Conf.TIM_Clock = 1.0E+6;\r\n      TIM1_Conf.TIM_Freq = 1000.0;\r\n      TIM1_Conf.CH1_duty = 0.0;\r\n      TIM1_Conf.CH2_duty = 0.0;\r\n      TIM1_Conf.CH3_duty = 10.0;\r\n      TIM1_Conf.CH4_duty = 5.0;\r\n      TIM1_Conf.CH1_type = UNKNOWN;\r\n      TIM1_Conf.CH2_type = UNKNOWN;\r\n      TIM1_Conf.CH3_type = OUTPUT_PWM;\r\n      TIM1_Conf.CH4_type = OUTPUT_PWM;\r\n\r\n      /* Interrupt handler default initialization. */\r\n      TIM1_Conf.ItUpFcn = NULL;\r\n      TIM1_Conf.ItTrgFcn = NULL;\r\n      TIM1_Conf.ItComFcn = NULL;\r\n      TIM1_Conf.ItBrkFcn = NULL;\r\n      TIM1_Conf.ItCcFcn = NULL;\r\n\r\n      /* Auto-reload preload enable */\r\n      /*****Bugzilla 63376 *****/\r\n      /*SET_BIT((&htim1)->Instance->CR1,TIM_CR1_ARPE);*/\r\n\r\n      /* Update register value with blockset value. */\r\n      /* Prescaler. */\r\n      __HAL_TIM_SET_PRESCALER(&htim1,TIM1_Conf.TIM_Prescaler);\r\n\r\n      /* Autoreload: ARR. */\r\n      __HAL_TIM_SET_AUTORELOAD(&htim1,1000 - 1);\r\n\r\n      /* Set CH4 Pulse value. */\r\n      __HAL_TIM_SET_COMPARE(&htim1,TIM_CHANNEL_4,(uint32_t)(50));\r\n\r\n      /* Update registers before start operation to come. */\r\n      HAL_TIM_GenerateEvent(&htim1,TIM_EVENTSOURCE_UPDATE);\r\n    }\r\n\r\n    {\r\n      /* TIM2 initialization. */\r\n      /* Store TIM2 informations and its handler. */\r\n      G_TIM_Conf[G_TIM_Count] = &TIM2_Conf;\r\n      G_TIM_Handler[G_TIM_Count] = &htim2;\r\n      G_TIM_Count++;\r\n\r\n      /* Store TIM information. */\r\n      TIM2_Conf.TIM_Prescaler = 3;\r\n      TIM2_Conf.TIM_APBClock = 84000000;\r\n      TIM2_Conf.TIM_ARR = 2100 - 1;\r\n      TIM2_Conf.TIM_Clock = 2.1E+7;\r\n      TIM2_Conf.TIM_Freq = 10000.0;\r\n      TIM2_Conf.CH1_duty = 0.0;\r\n      TIM2_Conf.CH2_duty = 0.0;\r\n      TIM2_Conf.CH3_duty = 0.0;\r\n      TIM2_Conf.CH4_duty = 0.0;\r\n      TIM2_Conf.CH1_type = INPUT_ENCODER;\r\n      TIM2_Conf.CH2_type = INPUT_ENCODER;\r\n      TIM2_Conf.CH3_type = UNKNOWN;\r\n      TIM2_Conf.CH4_type = UNKNOWN;\r\n\r\n      /* Interrupt handler default initialization. */\r\n      TIM2_Conf.ItUpFcn = NULL;\r\n      TIM2_Conf.ItTrgFcn = NULL;\r\n      TIM2_Conf.ItComFcn = NULL;\r\n      TIM2_Conf.ItBrkFcn = NULL;\r\n      TIM2_Conf.ItCcFcn = NULL;\r\n\r\n      /* Auto-reload preload enable */\r\n      /*****Bugzilla 63376 *****/\r\n      /*SET_BIT((&htim2)->Instance->CR1,TIM_CR1_ARPE);*/\r\n\r\n      /* Update register value with blockset value. */\r\n      /* Prescaler. */\r\n      __HAL_TIM_SET_PRESCALER(&htim2,TIM2_Conf.TIM_Prescaler);\r\n\r\n      /* Autoreload: ARR. */\r\n      __HAL_TIM_SET_AUTORELOAD(&htim2,2100 - 1);\r\n\r\n      /* Update registers before start operation to come. */\r\n      HAL_TIM_GenerateEvent(&htim2,TIM_EVENTSOURCE_UPDATE);\r\n    }\r\n\r\n    {\r\n      /* TIM6 initialization. */\r\n      /* Store TIM6 informations and its handler. */\r\n      G_TIM_Conf[G_TIM_Count] = &TIM6_Conf;\r\n      G_TIM_Handler[G_TIM_Count] = &htim6;\r\n      G_TIM_Count++;\r\n\r\n      /* Store TIM information. */\r\n      TIM6_Conf.TIM_Prescaler = 8399;\r\n      TIM6_Conf.TIM_APBClock = 84000000;\r\n      TIM6_Conf.TIM_ARR = 200 - 1;\r\n      TIM6_Conf.TIM_Clock = 10000.0;\r\n      TIM6_Conf.TIM_Freq = 50.0;\r\n      TIM6_Conf.CH1_duty = 0.0;\r\n      TIM6_Conf.CH2_duty = 0.0;\r\n      TIM6_Conf.CH3_duty = 0.0;\r\n      TIM6_Conf.CH4_duty = 0.0;\r\n      TIM6_Conf.CH1_type = UNKNOWN;\r\n      TIM6_Conf.CH2_type = UNKNOWN;\r\n      TIM6_Conf.CH3_type = UNKNOWN;\r\n      TIM6_Conf.CH4_type = UNKNOWN;\r\n\r\n      /* Interrupt handler default initialization. */\r\n      TIM6_Conf.ItUpFcn = NULL;\r\n      TIM6_Conf.ItTrgFcn = NULL;\r\n      TIM6_Conf.ItComFcn = NULL;\r\n      TIM6_Conf.ItBrkFcn = NULL;\r\n      TIM6_Conf.ItCcFcn = NULL;\r\n\r\n      /* Update interrupt function. */\r\n      TIM6_Conf.ItUpFcn = TIM6_ItUpFcn;\r\n\r\n      /* Auto-reload preload enable */\r\n      /*****Bugzilla 63376 *****/\r\n      /*SET_BIT((&htim6)->Instance->CR1,TIM_CR1_ARPE);*/\r\n\r\n      /* Update register value with blockset value. */\r\n      /* Prescaler. */\r\n      __HAL_TIM_SET_PRESCALER(&htim6,TIM6_Conf.TIM_Prescaler);\r\n\r\n      /* Autoreload: ARR. */\r\n      __HAL_TIM_SET_AUTORELOAD(&htim6,200 - 1);\r\n\r\n      /* Update registers before start operation to come. */\r\n      HAL_TIM_GenerateEvent(&htim6,TIM_EVENTSOURCE_UPDATE);\r\n    }\r\n\r\n    {\r\n      /* TIM3 initialization. */\r\n      /* Store TIM3 informations and its handler. */\r\n      G_TIM_Conf[G_TIM_Count] = &TIM3_Conf;\r\n      G_TIM_Handler[G_TIM_Count] = &htim3;\r\n      G_TIM_Count++;\r\n\r\n      /* Store TIM information. */\r\n      TIM3_Conf.TIM_Prescaler = 8399;\r\n      TIM3_Conf.TIM_APBClock = 84000000;\r\n      TIM3_Conf.TIM_ARR = 100 - 1;\r\n      TIM3_Conf.TIM_Clock = 10000.0;\r\n      TIM3_Conf.TIM_Freq = 100.0;\r\n      TIM3_Conf.CH1_duty = 0.0;\r\n      TIM3_Conf.CH2_duty = 0.0;\r\n      TIM3_Conf.CH3_duty = 0.0;\r\n      TIM3_Conf.CH4_duty = 0.0;\r\n      TIM3_Conf.CH1_type = UNKNOWN;\r\n      TIM3_Conf.CH2_type = UNKNOWN;\r\n      TIM3_Conf.CH3_type = UNKNOWN;\r\n      TIM3_Conf.CH4_type = UNKNOWN;\r\n\r\n      /* Interrupt handler default initialization. */\r\n      TIM3_Conf.ItUpFcn = NULL;\r\n      TIM3_Conf.ItTrgFcn = NULL;\r\n      TIM3_Conf.ItComFcn = NULL;\r\n      TIM3_Conf.ItBrkFcn = NULL;\r\n      TIM3_Conf.ItCcFcn = NULL;\r\n\r\n      /* Update interrupt function. */\r\n      TIM3_Conf.ItUpFcn = TIM3_ItUpFcn;\r\n\r\n      /* Auto-reload preload enable */\r\n      /*****Bugzilla 63376 *****/\r\n      /*SET_BIT((&htim3)->Instance->CR1,TIM_CR1_ARPE);*/\r\n\r\n      /* Update register value with blockset value. */\r\n      /* Prescaler. */\r\n      __HAL_TIM_SET_PRESCALER(&htim3,TIM3_Conf.TIM_Prescaler);\r\n\r\n      /* Autoreload: ARR. */\r\n      __HAL_TIM_SET_AUTORELOAD(&htim3,100 - 1);\r\n\r\n      /* Update registers before start operation to come. */\r\n      HAL_TIM_GenerateEvent(&htim3,TIM_EVENTSOURCE_UPDATE);\r\n    }\r\n\r\n    /* user code (Start function Body) */\r\n    {\r\n      /* TIM1 Start. */\r\n\r\n      /* Wait for htim1 State READY. */\r\n      while ((&htim1)->State == HAL_TIM_STATE_BUSY) {\r\n      }\r\n\r\n      HAL_TIM_PWM_Start(&htim1,TIM_CHANNEL_4);\r\n    }\r\n\r\n    {\r\n      /* TIM2 Start. */\r\n      HAL_TIM_Encoder_Start_IT(&htim2,TIM_CHANNEL_ALL);\r\n\r\n      /* Wait for htim2 State READY. */\r\n      while ((&htim2)->State == HAL_TIM_STATE_BUSY) {\r\n      }\r\n\r\n      /* Wait for htim2 State READY. */\r\n      while ((&htim2)->State == HAL_TIM_STATE_BUSY) {\r\n      }\r\n    }\r\n\r\n    /* USART2 initialization for send. */\r\n    USART2_Tx_Initialization();\r\n\r\n    {\r\n      /* TIM6 Start. */\r\n      /* Starts the TIM Base generation in interrupt mode. */\r\n      HAL_TIM_Base_Start_IT(&htim6);\r\n\r\n      /* Start interrupt for Update event*/\r\n      HAL_TIM_Base_Start_IT(&htim6);\r\n    }\r\n\r\n    {\r\n      /* TIM3 Start. */\r\n      /* Starts the TIM Base generation in interrupt mode. */\r\n      HAL_TIM_Base_Start_IT(&htim3);\r\n\r\n      /* Start interrupt for Update event*/\r\n      HAL_TIM_Base_Start_IT(&htim3);\r\n    }\r\n\r\n    {\r\n      /* HAL CAN1 filter configuration structure definition. */\r\n      CAN_FilterTypeDef sFilterConfig = { 0 };\r\n\r\n      sFilterConfig.FilterIdHigh = 0x0;\r\n      sFilterConfig.FilterIdLow = 0x0;\r\n      sFilterConfig.FilterMaskIdHigh = 0x0;\r\n      sFilterConfig.FilterMaskIdLow = 0x0;\r\n      sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;\r\n      sFilterConfig.FilterBank = 0;\r\n      sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;\r\n      sFilterConfig.FilterScale = CAN_FILTERSCALE_16BIT;\r\n      sFilterConfig.FilterActivation = ENABLE;\r\n      sFilterConfig.SlaveStartFilterBank = 14;\r\n\r\n      /* Configure CAN1 filter on dedicated FIFO0. */\r\n      if (HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig)!= HAL_OK) {\r\n        Error_Handler();\r\n      }\r\n    }\r\n\r\n    {\r\n      /* Interrupt case. */\r\n      {\r\n        /* Activate CAN RX notifications on dedicated FIFO0. */\r\n        const uint32_t activeITs = CAN_IT_RX_FIFO0_MSG_PENDING|\r\n          CAN_IT_RX_FIFO0_FULL|CAN_IT_RX_FIFO0_OVERRUN;\r\n        if (HAL_CAN_ActivateNotification(&hcan1, activeITs) != HAL_OK) {\r\n          Error_Handler();\r\n        }\r\n      }\r\n    }\r\n\r\n    xusiming_DW.execpt = 10.0;\r\n    xusiming_DW.kp = 1.0;\r\n    xusiming_DW.ki = 1.0;\r\n  }\r\n\r\n  xusiming_PrevZCX.Subsystem4_Trig_ZCE = UNINITIALIZED_ZCSIG;\r\n\r\n  /* Set Rx interrupt function for CAN1 */\r\n  Rx_ItFcn1 = CAN1_Rx_ItFcn;\r\n\r\n  /* Set Tx interrupt function for CAN1 */\r\n  Tx_ItFcn1 = CAN1_Tx_ItFcn;\r\n\r\n  /* Activate CAN Error notifications. */\r\n  {\r\n    const uint32_t activeITs = CAN_IT_ERROR_WARNING|CAN_IT_ERROR_PASSIVE|\r\n      CAN_IT_LAST_ERROR_CODE| CAN_IT_ERROR;\r\n    if (HAL_CAN_ActivateNotification(&hcan1, activeITs) != HAL_OK) {\r\n      Error_Handler();\r\n    }\r\n  }\r\n\r\n  /* System initialize for function-call system: '<Root>/Subsystem1' */\r\n\r\n  /* Asynchronous task (with no priority assigned)\r\n   * reads absolute time */\r\n  switch (xusiming_M->Timing.rtmDbBufWriteBuf3) {\r\n   case 0:\r\n    xusiming_M->Timing.rtmDbBufReadBuf3 = 1;\r\n    break;\r\n\r\n   case 1:\r\n    xusiming_M->Timing.rtmDbBufReadBuf3 = 0;\r\n    break;\r\n\r\n   default:\r\n    xusiming_M->Timing.rtmDbBufReadBuf3 = xusiming_M->Timing.rtmDbBufLastBufWr3;\r\n    break;\r\n  }\r\n\r\n  xusiming_M->Timing.clockTick3 = xusiming_M->\r\n    Timing.rtmDbBufClockTick3[xusiming_M->Timing.rtmDbBufReadBuf3];\r\n  xusiming_M->Timing.rtmDbBufReadBuf3 = 0xFF;\r\n\r\n  {\r\n    /* Interrupt case. */\r\n    /* Activate CAN TX notifications. */\r\n    {\r\n      const uint32_t activeITs = CAN_IT_TX_MAILBOX_EMPTY;\r\n      if (HAL_CAN_ActivateNotification(&hcan1, activeITs) != HAL_OK) {\r\n        Error_Handler();\r\n      }\r\n    }\r\n\r\n    /* Start CAN1. */\r\n    if (HAL_CAN_Start(&hcan1) != HAL_OK) {\r\n      Error_Handler();\r\n    }\r\n  }\r\n\r\n  ;\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] xusiming.c\r\n */\r\n"},{"name":"xusiming.h","type":"header","group":"model","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: xusiming.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_xusiming_h_\r\n#define RTW_HEADER_xusiming_h_\r\n#ifndef xusiming_COMMON_INCLUDES_\r\n#define xusiming_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"getBuffPtr.h\"\r\n#endif                                 /* xusiming_COMMON_INCLUDES_ */\r\n\r\n#include \"xusiming_CAN.h\"\r\n#include \"xusiming_TIM.h\"\r\n#include \"xusiming_USART.h\"\r\n#include \"STM32_Config.h\"\r\n#include \"xusiming_External_Functions.h\"\r\n#include \"xusiming_types.h\"\r\n#include \"rt_zcfcn.h\"\r\n#include \"rtGetInf.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"zero_crossing_types.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* user code (top of header file) */\r\n#include \"string.h\"\r\n#include \"xusiming_private.h\"\r\n#include \"math.h\"\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T GPIO_Read1;                   /* '<Root>/GPIO_Read1' */\r\n  real_T DiscreteTimeIntegrator1;      /* '<S1>/Discrete-Time Integrator1' */\r\n  uint32_T Timers1_o2;                 /* '<S2>/Timers1' */\r\n  uint32_T Timers2_o1;                 /* '<S2>/Timers2' */\r\n  uint32_T Timers2_o2;                 /* '<S2>/Timers2' */\r\n  uint32_T BuffPtr;                    /* '<S2>/RcvUsartBuf4' */\r\n  uint32_T CAN_Read_Data_o3;           /* '<S4>/CAN_Read_Data' */\r\n  uint16_T CAN_NbPendingMsg;           /* '<Root>/CAN_NbPendingMsg' */\r\n  uint16_T USART_Send2;                /* '<S2>/USART_Send2' */\r\n  uint16_T CAN_Read_Data_o5;           /* '<S4>/CAN_Read_Data' */\r\n  uint8_T TmpRTBAtSubsystem2Outport1;  /* '<Root>/Subsystem2' */\r\n  uint8_T Timers1_o1;                  /* '<S2>/Timers1' */\r\n  uint8_T DataTypeConversion;          /* '<S1>/Data Type Conversion' */\r\n  uint8_T DataTypeConversion1;         /* '<S1>/Data Type Conversion1' */\r\n  uint8_T DataTypeConversion3;         /* '<S1>/Data Type Conversion3' */\r\n  uint8_T CAN_Read_Data_o1;            /* '<S4>/CAN_Read_Data' */\r\n  uint8_T CAN_Read_Data_o2;            /* '<S4>/CAN_Read_Data' */\r\n  uint8_T CAN_Read_Data_o4;            /* '<S4>/CAN_Read_Data' */\r\n  uint8_T CAN_Read_Data_o6[8];         /* '<S4>/CAN_Read_Data' */\r\n  boolean_T GPIO_Read;                 /* '<Root>/GPIO_Read' */\r\n} B_xusiming;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T DiscreteTimeIntegrator1_DSTATE;/* '<S1>/Discrete-Time Integrator1' */\r\n  real_T Delay1_DSTATE;                /* '<S1>/Delay1' */\r\n  real_T DiscreteTimeIntegrator_DSTATE;/* '<S1>/Discrete-Time Integrator' */\r\n  real_T execpt;                       /* '<Root>/Data Store Memory' */\r\n  real_T kp;                           /* '<Root>/Data Store Memory1' */\r\n  real_T ki;                           /* '<Root>/Data Store Memory2' */\r\n  real_T DiscreteTimeIntegrator1_PREV_U;/* '<S1>/Discrete-Time Integrator1' */\r\n  real_T DiscreteTimeIntegrator_PREV_U;/* '<S1>/Discrete-Time Integrator' */\r\n  uint32_T Subsystem1_PREV_T;          /* '<Root>/Subsystem1' */\r\n  uint8_T DiscreteTimeIntegrator1_SYSTEM_ENABLE;/* '<S1>/Discrete-Time Integrator1' */\r\n  uint8_T DiscreteTimeIntegrator_SYSTEM_ENABLE;/* '<S1>/Discrete-Time Integrator' */\r\n  boolean_T Subsystem1_RESET_ELAPS_T;  /* '<Root>/Subsystem1' */\r\n} DW_xusiming;\r\n\r\n/* Zero-crossing (trigger) state */\r\ntypedef struct {\r\n  ZCSigState Subsystem4_Trig_ZCE;      /* '<Root>/Subsystem4' */\r\n} PrevZCX_xusiming;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_xusiming {\r\n  const char_T * volatile errorStatus;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n    uint32_T clockTick3;\r\n    uint8_T rtmDbBufReadBuf3;\r\n    uint8_T rtmDbBufWriteBuf3;\r\n    boolean_T rtmDbBufLastBufWr3;\r\n    uint32_T rtmDbBufClockTick3[2];\r\n  } Timing;\r\n};\r\n\r\n/* Block signals (default storage) */\r\nextern B_xusiming xusiming_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_xusiming xusiming_DW;\r\n\r\n/* Zero-crossing (trigger) state */\r\nextern PrevZCX_xusiming xusiming_PrevZCX;\r\n\r\n/* Model entry point functions */\r\nextern void xusiming_initialize(void);\r\nextern void xusiming_step(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_xusiming *const xusiming_M;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S2>/Data Type Conversion2' : Unused code path elimination\r\n * Block '<S1>/Data Type Conversion2' : Eliminate redundant data type conversion\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'xusiming'\r\n * '<S1>'   : 'xusiming/Subsystem1'\r\n * '<S2>'   : 'xusiming/Subsystem2'\r\n * '<S3>'   : 'xusiming/Subsystem4'\r\n * '<S4>'   : 'xusiming/Subsystem5'\r\n * '<S5>'   : 'xusiming/Subsystem1/MATLAB Function'\r\n * '<S6>'   : 'xusiming/Subsystem2/MATLAB Function'\r\n * '<S7>'   : 'xusiming/Subsystem2/RcvUsartBuf4'\r\n * '<S8>'   : 'xusiming/Subsystem5/If Action Subsystem'\r\n * '<S9>'   : 'xusiming/Subsystem5/If Action Subsystem1'\r\n * '<S10>'  : 'xusiming/Subsystem5/If Action Subsystem/If Action Subsystem'\r\n * '<S11>'  : 'xusiming/Subsystem5/If Action Subsystem/If Action Subsystem1'\r\n * '<S12>'  : 'xusiming/Subsystem5/If Action Subsystem/If Action Subsystem2'\r\n * '<S13>'  : 'xusiming/Subsystem5/If Action Subsystem/If Action Subsystem3'\r\n * '<S14>'  : 'xusiming/Subsystem5/If Action Subsystem/If Action Subsystem4'\r\n * '<S15>'  : 'xusiming/Subsystem5/If Action Subsystem/If Action Subsystem5'\r\n */\r\n#endif                                 /* RTW_HEADER_xusiming_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] xusiming.h\r\n */\r\n"},{"name":"xusiming_private.h","type":"header","group":"model","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: xusiming_private.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_xusiming_private_h_\r\n#define RTW_HEADER_xusiming_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"zero_crossing_types.h\"\r\n#include \"xusiming.h\"\r\n\r\nextern void xusiming_Subsystem5(void);\r\nvoid xusiming_ASYNC5(int controlPortIdx);\r\n\r\n#endif                                 /* RTW_HEADER_xusiming_private_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] xusiming_private.h\r\n */\r\n"},{"name":"xusiming_types.h","type":"header","group":"model","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: xusiming_types.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_xusiming_types_h_\r\n#define RTW_HEADER_xusiming_types_h_\r\n\r\n/* Model Code Variants */\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_xusiming RT_MODEL_xusiming;\r\n\r\n#endif                                 /* RTW_HEADER_xusiming_types_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] xusiming_types.h\r\n */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetInf.c\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] rtGetInf.c\r\n */\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetInf.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] rtGetInf.h\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] rtGetNaN.c\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] rtGetNaN.h\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] rt_nonfinite.c\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] rt_nonfinite.h\r\n */\r\n"},{"name":"rt_zcfcn.c","type":"source","group":"utility","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rt_zcfcn.c\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"zero_crossing_types.h\"\r\n#include \"rt_zcfcn.h\"\r\n#include \"solver_zc.h\"\r\n\r\n/* Detect zero crossings events. */\r\nZCEventType rt_ZCFcn(ZCDirection zcDir, ZCSigState* prevZc, real_T currValue)\r\n{\r\n  slZcEventType zcsDir;\r\n  slZcEventType tempEv;\r\n  ZCEventType zcEvent = NO_ZCEVENT;    /* assume */\r\n\r\n  /* zcEvent matrix */\r\n  static const slZcEventType eventMatrix[4][4] = {\r\n    /*          ZER              POS              NEG              UNK */\r\n    { SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_Z2P, SL_ZCS_EVENT_Z2N, SL_ZCS_EVENT_NUL },/* ZER */\r\n\r\n    { SL_ZCS_EVENT_P2Z, SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_P2N, SL_ZCS_EVENT_NUL },/* POS */\r\n\r\n    { SL_ZCS_EVENT_N2Z, SL_ZCS_EVENT_N2P, SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_NUL },/* NEG */\r\n\r\n    { SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_NUL }/* UNK */\r\n  };\r\n\r\n  /* get prevZcEvent and prevZcSign from prevZc */\r\n  const slZcEventType prevEv = (slZcEventType)(((uint8_T)(*prevZc)) >> 2);\r\n  const slZcSignalSignType prevSign = (slZcSignalSignType)(((uint8_T)(*prevZc))\r\n    & (uint8_T)0x03);\r\n\r\n  /* get current zcSignal sign from current zcSignal value */\r\n  const slZcSignalSignType currSign = (slZcSignalSignType)((currValue) > 0.0 ?\r\n    SL_ZCS_SIGN_POS :\r\n    ((currValue) < 0.0 ? SL_ZCS_SIGN_NEG : SL_ZCS_SIGN_ZERO));\r\n\r\n  /* get current zcEvent based on prev and current zcSignal value */\r\n  slZcEventType currEv = eventMatrix[prevSign][currSign];\r\n\r\n  /* get slZcEventType from ZCDirection */\r\n  switch (zcDir) {\r\n   case ANY_ZERO_CROSSING:\r\n    zcsDir = SL_ZCS_EVENT_ALL;\r\n    break;\r\n\r\n   case FALLING_ZERO_CROSSING:\r\n    zcsDir = SL_ZCS_EVENT_ALL_DN;\r\n    break;\r\n\r\n   case RISING_ZERO_CROSSING:\r\n    zcsDir = SL_ZCS_EVENT_ALL_UP;\r\n    break;\r\n\r\n   default:\r\n    zcsDir = SL_ZCS_EVENT_NUL;\r\n    break;\r\n  }\r\n\r\n  /*had event, check if double zc happend remove double detection. */\r\n  if (slZcHadEvent(currEv, zcsDir)) {\r\n    currEv = (slZcEventType)(slZcUnAliasEvents(prevEv, currEv));\r\n  } else {\r\n    currEv = SL_ZCS_EVENT_NUL;\r\n  }\r\n\r\n  /* Update prevZc */\r\n  tempEv = (slZcEventType)(currEv << 2);/* shift left by 2 bits */\r\n  *prevZc = (ZCSigState)((currSign) | (tempEv));\r\n  if ((currEv & SL_ZCS_EVENT_ALL_DN) != 0) {\r\n    zcEvent = FALLING_ZCEVENT;\r\n  } else if ((currEv & SL_ZCS_EVENT_ALL_UP) != 0) {\r\n    zcEvent = RISING_ZCEVENT;\r\n  } else {\r\n    zcEvent = NO_ZCEVENT;\r\n  }\r\n\r\n  return zcEvent;\r\n}                                      /* rt_ZCFcn */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] rt_zcfcn.c\r\n */\r\n"},{"name":"rt_zcfcn.h","type":"header","group":"utility","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rt_zcfcn.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_zcfcn_h_\r\n#define RTW_HEADER_rt_zcfcn_h_\r\n#include \"rtwtypes.h\"\r\n#include \"zero_crossing_types.h\"\r\n#include \"solver_zc.h\"\r\n#ifndef slZcHadEvent\r\n#define slZcHadEvent(ev, zcsDir)       (((ev) & (zcsDir)) != 0x00 )\r\n#endif\r\n\r\n#ifndef slZcUnAliasEvents\r\n#define slZcUnAliasEvents(evL, evR)    ((((slZcHadEvent((evL), (SL_ZCS_EVENT_N2Z)) && slZcHadEvent((evR), (SL_ZCS_EVENT_Z2P))) || (slZcHadEvent((evL), (SL_ZCS_EVENT_P2Z)) && slZcHadEvent((evR), (SL_ZCS_EVENT_Z2N)))) ? (SL_ZCS_EVENT_NUL) : (evR)))\r\n#endif\r\n\r\nextern ZCEventType rt_ZCFcn(ZCDirection zcDir, ZCSigState *prevZc, real_T\r\n  currValue);\r\n\r\n#endif                                 /* RTW_HEADER_rt_zcfcn_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] rt_zcfcn.h\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: Intel->x86-64 (Windows64)\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  64\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] rtwtypes.h\r\n */\r\n"},{"name":"zero_crossing_types.h","type":"header","group":"utility","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: zero_crossing_types.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef ZERO_CROSSING_TYPES_H\r\n#define ZERO_CROSSING_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/* Trigger directions: falling, either, and rising */\r\ntypedef enum {\r\n  FALLING_ZERO_CROSSING = -1,\r\n  ANY_ZERO_CROSSING = 0,\r\n  RISING_ZERO_CROSSING = 1\r\n} ZCDirection;\r\n\r\n/* Previous state of a trigger signal */\r\ntypedef uint8_T ZCSigState;\r\n\r\n/* Initial value of a trigger zero crossing signal */\r\n#define UNINITIALIZED_ZCSIG            0x03U\r\n#define NEG_ZCSIG                      0x02U\r\n#define POS_ZCSIG                      0x01U\r\n#define ZERO_ZCSIG                     0x00U\r\n\r\n/* Current state of a trigger signal */\r\ntypedef enum { FALLING_ZCEVENT = -1, NO_ZCEVENT = 0, RISING_ZCEVENT = 1 }\r\n  ZCEventType;\r\n\r\n#endif                                 /* ZERO_CROSSING_TYPES_H */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] zero_crossing_types.h\r\n */\r\n"},{"name":"STM32_Config.h","type":"header","group":"","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Other files","code":"/*\r\n * File: STM32_Config.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_STM32_Config_h_\r\n#define RTW_HEADER_STM32_Config_h_\r\n#include \"stm32f4xx.h\"\r\n#include \"stm32f4xx_hal.h\"\r\n\r\n/* For Error_Handler() declaration. */\r\n#include \"main.h\"\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* RTW_HEADER_STM32_Config_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] STM32_Config.h\r\n */\r\n"},{"name":"main.c","type":"source","group":"","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Other files","code":"/*\r\n * File: main.c\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n/* This section of code is going to be merged by the STM32CubeMX tool. */\r\n/* USER CODE BEGIN 0 */\r\n#include <stdio.h>\r\n#include \"xusiming.h\"\r\n#include \"rtwtypes.h\"\r\n\r\n/* Flags for taskOverrun */\r\nstatic boolean_T OverrunFlags[1] = { false, };\r\n\r\n/* Number of auto reload timer rotation computed */\r\nstatic volatile uint32_t autoReloadTimerLoopVal_S = 1;\r\n\r\n/* Remaining number of auto reload timer rotation to do */\r\nvolatile uint32_t remainAutoReloadTimerLoopVal_S = 1;\r\n\r\n/* USER CODE END 0 */\r\n\r\n/**\r\n * @brief  The application entry point.\r\n * @retval int\r\n */\r\nint main (void)\r\n{\r\n  /* This section of code is going to be merged by the STM32CubeMX tool. */\r\n  /* USER CODE BEGIN 1 */\r\n  /* USER CODE END 1 */\r\n\r\n  /* This section of code is going to be merged by the STM32CubeMX tool. */\r\n  /* USER CODE BEGIN 2 */\r\n  /* Use Systick arm timer and interrupt to tick step() functions of the Simulink model. */\r\n  /* Fundamental sample time is set to: '0.001000000' s */\r\n  if (SysTick_Config((uint32_t)(SystemCoreClock/1000.0))) {\r\n    autoReloadTimerLoopVal_S = 1;\r\n    do {\r\n      autoReloadTimerLoopVal_S++;\r\n    } while ((uint32_t)(SystemCoreClock/1000.0)/autoReloadTimerLoopVal_S >\r\n             SysTick_LOAD_RELOAD_Msk);\r\n\r\n    SysTick_Config((uint32_t)(SystemCoreClock/1000.0)/autoReloadTimerLoopVal_S);\r\n  }\r\n\r\n  /* Set number of loop to do. */\r\n  remainAutoReloadTimerLoopVal_S = autoReloadTimerLoopVal_S;\r\n\r\n  {\r\n    int i;\r\n    for (i = 0; i < 1; i++) {\r\n      OverrunFlags[i] = false;\r\n    }\r\n  }\r\n\r\n  /* Initialize model */\r\n  xusiming_initialize();\r\n\r\n  /* USER CODE END 2 */\r\n\r\n  /* This section of code is going to be merged by the STM32CubeMX tool. */\r\n  /* USER CODE BEGIN WHILE */\r\n  /* Infinite loop */\r\n  /* Real time from systickHandler */\r\n  while (1) {\r\n    /*Process tasks every solver time*/\r\n    if (remainAutoReloadTimerLoopVal_S == 0) {\r\n      remainAutoReloadTimerLoopVal_S = autoReloadTimerLoopVal_S;\r\n\r\n      /* Check base rate for overrun */\r\n      if (OverrunFlags[0]) {\r\n        rtmSetErrorStatus(xusiming_M, \"Overrun\");\r\n      }\r\n\r\n      OverrunFlags[0] = true;\r\n\r\n      /* Step the model for base rate */\r\n      xusiming_step();\r\n\r\n      /* Get model outputs here */\r\n\r\n      /* Indicate task for base rate complete */\r\n      OverrunFlags[0] = false;\r\n    }\r\n  }\r\n\r\n  /* USER CODE END WHILE */\r\n\r\n  /* USER CODE BEGIN 3 */\r\n  /* USER CODE END 3 */\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] main.c\r\n */\r\n"},{"name":"stm32xxxx_it.c","type":"source","group":"","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Other files","code":"/*\r\n * File: stm32xxxx_it.c\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n/**\r\n * @brief This function handles System tick timer.\r\n */\r\nvoid SysTick_Handler(void)\r\n{\r\n  /* This section of code is going to be merged by the STM32CubeMX tool. */\r\n  /* USER CODE BEGIN SysTick_IRQn 0 */\r\n  {\r\n    extern volatile uint32_t remainAutoReloadTimerLoopVal_S;\r\n\r\n    /* Manage number of loop before interrupt has to be processed. */\r\n    if (remainAutoReloadTimerLoopVal_S) {\r\n      remainAutoReloadTimerLoopVal_S--;\r\n    }\r\n  }\r\n\r\n  /* USER CODE END SysTick_IRQn 0 */\r\n\r\n  /* USER CODE BEGIN SysTick_IRQn 1 */\r\n\r\n  /* USER CODE END SysTick_IRQn 1 */\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] stm32xxxx_it.c\r\n */\r\n"},{"name":"xusiming_CAN.c","type":"source","group":"","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Other files","code":"/*\r\n * File: xusiming_CAN.c\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"xusiming.h\"\r\n#include \"xusiming_CAN.h\"\r\n\r\n/* Interrupt pointer callback function definition. */\r\nvoid (* Rx_ItFcn1)(void) = NULL;\r\nvoid (* Tx_ItFcn1)(void) = NULL;\r\nvoid (* Error_ItFcn1)(void) = NULL;\r\n\r\n/**\r\n * @brief  Rx FIFO 0 message pending callback.\r\n * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  if (Rx_ItFcn1 != NULL) {\r\n    Rx_ItFcn1();\r\n  } else {\r\n    Error_Handler();\r\n  }\r\n}\r\n\r\n/**\r\n * @brief  Rx FIFO 1 message pending callback.\r\n * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  if (Rx_ItFcn1 != NULL) {\r\n    Rx_ItFcn1();\r\n  } else {\r\n    Error_Handler();\r\n  }\r\n}\r\n\r\n/**\r\n * @brief  Rx FIFO 0 full callback.\r\n * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  if (Rx_ItFcn1 != NULL) {\r\n    Rx_ItFcn1();\r\n  } else {\r\n    Error_Handler();\r\n  }\r\n}\r\n\r\n/**\r\n * @brief  Rx FIFO 1 full callback.\r\n * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  if (Rx_ItFcn1 != NULL) {\r\n    Rx_ItFcn1();\r\n  } else {\r\n    Error_Handler();\r\n  }\r\n}\r\n\r\n/**\r\n * @brief  Transmission Mailbox 0 complete callback.\r\n * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Call CANx transmit complete function. */\r\n  if (Tx_ItFcn1 != NULL) {\r\n    Tx_ItFcn1();\r\n  } else {\r\n    Error_Handler();\r\n  }\r\n}\r\n\r\n/**\r\n * @brief  Transmission Mailbox 1 complete callback.\r\n * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Call CANx transmit complete function. */\r\n  if (Tx_ItFcn1 != NULL) {\r\n    Tx_ItFcn1();\r\n  } else {\r\n    Error_Handler();\r\n  }\r\n}\r\n\r\n/**\r\n * @brief  Transmission Mailbox 2 complete callback.\r\n * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  /* Call CANx transmit complete function. */\r\n  if (Tx_ItFcn1 != NULL) {\r\n    Tx_ItFcn1();\r\n  } else {\r\n    Error_Handler();\r\n  }\r\n}\r\n\r\n/**\r\n * @brief  Transmission Mailbox 0 Cancellation callback.\r\n * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_TxMailbox0AbortCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  UNUSED(hcan);\r\n}\r\n\r\n/**\r\n * @brief  Transmission Mailbox 1 Cancellation callback.\r\n * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_TxMailbox1AbortCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  UNUSED(hcan);\r\n}\r\n\r\n/**\r\n * @brief  Transmission Mailbox 2 Cancellation callback.\r\n * @param  hcan pointer to an CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_TxMailbox2AbortCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  UNUSED(hcan);\r\n}\r\n\r\n/**\r\n * @brief  Sleep callback.\r\n * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_SleepCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  UNUSED(hcan);\r\n}\r\n\r\n/**\r\n * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_WakeUpFromRxMsgCallback(CAN_HandleTypeDef *hcan)\r\n{\r\n  UNUSED(hcan);\r\n}\r\n\r\n/**\r\n * @brief  Error CAN callback.\r\n * @param  hcan pointer to a CAN_HandleTypeDef structure that contains\r\n *         the configuration information for the specified CAN.\r\n * @retval None\r\n */\r\nvoid HAL_CAN_ErrorCallback(CAN_HandleTypeDef* hcan)\r\n{\r\n  /* Call CANx error function. */\r\n  if (Error_ItFcn1 != NULL) {\r\n    Error_ItFcn1();\r\n  } else {\r\n    Error_Handler();\r\n  }\r\n}\r\n\r\n/*******************************************************************************\r\n * Function Name  : CAN1_Rx_ItFcn\r\n * Description    : CAN1 End of receive interrupt\r\n * Input          : None\r\n *******************************************************************************/\r\nvoid CAN1_Rx_ItFcn()\r\n{\r\n  xusiming_ASYNC5(0);\r\n}\r\n\r\n/*******************************************************************************\r\n * Function Name  : CAN1_Tx_ItFcn\r\n * Description    : CAN1 End of transmit interrupt\r\n * Input          : None\r\n *******************************************************************************/\r\nvoid CAN1_Tx_ItFcn()\r\n{\r\n  xusiming_ASYNC5(1);\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] xusiming_CAN.c\r\n */\r\n"},{"name":"xusiming_CAN.h","type":"header","group":"","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Other files","code":"/*\r\n * File: xusiming_CAN.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_xusiming_CAN_h_\r\n#define RTW_HEADER_xusiming_CAN_h_\r\n#include \"STM32_Config.h\"\r\n\r\n/* CAN1 handler declaration. */\r\nextern CAN_HandleTypeDef hcan1;\r\n\r\n/* Interrupt pointer callback function declaration. */\r\nextern void (* Rx_ItFcn1)(void);\r\nextern void (* Tx_ItFcn1)(void);\r\nextern void (* Error_ItFcn1)(void);\r\n\r\n/* CAN1 RX IT function */\r\nvoid CAN1_Rx_ItFcn(void);\r\n\r\n/* CAN1 TX IT function */\r\nvoid CAN1_Tx_ItFcn(void);\r\n\r\n#endif                                 /* RTW_HEADER_xusiming_CAN_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] xusiming_CAN.h\r\n */\r\n"},{"name":"xusiming_External_Functions.h","type":"header","group":"","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Other files","code":"/*\r\n * File: xusiming_External_Functions.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_xusiming_External_Functions_h_\r\n#define RTW_HEADER_xusiming_External_Functions_h_\r\n\r\n/* Generated by STM32_Config.*/\r\n/***** External Imported Functions *****/\r\n#endif                           /* RTW_HEADER_xusiming_External_Functions_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] xusiming_External_Functions.h\r\n */\r\n"},{"name":"xusiming_TIM.c","type":"source","group":"","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Other files","code":"/*\r\n * File: xusiming_TIM.c\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"xusiming.h\"\r\n#include \"xusiming_TIM.h\"\r\n\r\n/* Number of configured TIMER. */\r\nuint16_t G_TIM_Count = 0;\r\n\r\n/* Array of TIMER information. */\r\nTIM_ConfTypeDef* G_TIM_Conf[5];\r\nTIM_HandleTypeDef* G_TIM_Handler[5];\r\n\r\n/* TIM1 informations. */\r\nTIM_ConfTypeDef TIM1_Conf;\r\n\r\n/* TIM2 informations. */\r\nTIM_ConfTypeDef TIM2_Conf;\r\n\r\n/* TIM6 informations. */\r\nTIM_ConfTypeDef TIM6_Conf;\r\n\r\n/* TIM6 polling timeout value. Number of Solver loop. (can be changed). */\r\nuint32_t G_TIM6_PollTimeOut = 10;\r\n\r\n/* TIM3 informations. */\r\nTIM_ConfTypeDef TIM3_Conf;\r\n\r\n/*******************************************************************************\r\n * Function Name  : TIM_PeriodElapsedCustomCallback\r\n * Description    : Timer callback for update event\r\n * Input          : TIM_HandleTypeDef*   TIM IC handle\r\n *******************************************************************************/\r\nvoid TIM_PeriodElapsedCustomCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  TIM_ConfTypeDef * pConf = G_TIM_Conf[0];\r\n  TIM_HandleTypeDef* pHandler = G_TIM_Handler[0];\r\n\r\n  {\r\n    uint16_t idx = 0;\r\n    for (idx = 0;idx < 5;idx++) {\r\n      pHandler = G_TIM_Handler[idx];\r\n      if (pHandler == htim) {\r\n        pConf = G_TIM_Conf[idx];\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (pHandler == htim) {\r\n    if (pConf->ItUpFcn != NULL) {\r\n      /* Call update function for TIM6. */\r\n      pConf->ItUpFcn();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @brief  Period elapsed callback in non blocking mode\r\n * @param  htim TIM handle\r\n * @retval None\r\n */\r\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\r\n{\r\n  extern void TIM_PeriodElapsedCustomCallback(TIM_HandleTypeDef *htim);\r\n\r\n  /* Handle this event from model side. */\r\n  TIM_PeriodElapsedCustomCallback(htim);\r\n}\r\n\r\n/*******************************************************************************\r\n * Function Name  : TIM6_ItUpFcn\r\n * Description    : TIM6 update interrupt\r\n * Input          : None\r\n * TIM6_ItUpFcn is called from TIM_PeriodElapsedCustomCallback function\r\n * in xusiming_TIM.c file.\r\n *******************************************************************************/\r\nvoid TIM6_ItUpFcn()\r\n{\r\n  {\r\n    xusiming_B.TmpRTBAtSubsystem2Outport1 = xusiming_B.Timers1_o1;\r\n\r\n    /* Output and update for function-call system: '<Root>/Subsystem1' */\r\n    {\r\n      real_T DiscreteTimeIntegrator;\r\n      real_T rtb_Product;\r\n      real_T rtb_Product1;\r\n      real_T rtb_Sum1;\r\n      uint32_T Subsystem1_ELAPS_T;\r\n\r\n      /* Asynchronous task (with no priority assigned)\r\n       * reads absolute time */\r\n      switch (xusiming_M->Timing.rtmDbBufWriteBuf3) {\r\n       case 0:\r\n        xusiming_M->Timing.rtmDbBufReadBuf3 = 1;\r\n        break;\r\n\r\n       case 1:\r\n        xusiming_M->Timing.rtmDbBufReadBuf3 = 0;\r\n        break;\r\n\r\n       default:\r\n        xusiming_M->Timing.rtmDbBufReadBuf3 =\r\n          xusiming_M->Timing.rtmDbBufLastBufWr3;\r\n        break;\r\n      }\r\n\r\n      xusiming_M->Timing.clockTick3 = xusiming_M->\r\n        Timing.rtmDbBufClockTick3[xusiming_M->Timing.rtmDbBufReadBuf3];\r\n      xusiming_M->Timing.rtmDbBufReadBuf3 = 0xFF;\r\n      if (xusiming_DW.Subsystem1_RESET_ELAPS_T) {\r\n        Subsystem1_ELAPS_T = 0U;\r\n      } else {\r\n        Subsystem1_ELAPS_T = xusiming_M->Timing.clockTick3 -\r\n          xusiming_DW.Subsystem1_PREV_T;\r\n      }\r\n\r\n      xusiming_DW.Subsystem1_PREV_T = xusiming_M->Timing.clockTick3;\r\n      xusiming_DW.Subsystem1_RESET_ELAPS_T = false;\r\n\r\n      {\r\n        CAN_TxHeaderTypeDef txHeader = { 0 };\r\n\r\n        uint32_t txMailbox = 0;\r\n        uint8_t txData[8] = { 0 };\r\n\r\n        /* Build frame to send */\r\n        if (((uint16_T)0U) == CAN_ID_STD) {\r\n          txHeader.StdId = (uint32_t)((uint16_T)48U);\r\n          txHeader.ExtId = (uint32_t)0;\r\n          txHeader.IDE = CAN_ID_STD;\r\n        } else {\r\n          txHeader.StdId = (uint32_t)0;\r\n          txHeader.ExtId = (uint32_t)((uint16_T)48U);\r\n          txHeader.IDE = CAN_ID_EXT;\r\n        }\r\n\r\n        txHeader.RTR = (uint32_t)((uint16_T)0U);\r\n        txHeader.DLC = (uint32_t)((uint16_T)8U);\r\n        txHeader.TransmitGlobalTime = DISABLE;\r\n        txData[0] = xusiming_B.TmpRTBAtSubsystem2Outport1;\r\n        txData[1] = xusiming_B.DataTypeConversion3;\r\n        txData[2] = xusiming_B.DataTypeConversion;\r\n        txData[3] = xusiming_B.DataTypeConversion1;\r\n        txData[4] = 0U;\r\n        txData[5] = 0U;\r\n        txData[6] = 0U;\r\n        txData[7] = 0U;\r\n\r\n        {\r\n          /* Request transmission. */\r\n          if (HAL_CAN_AddTxMessage(&hcan1, &txHeader, &txData[0], &txMailbox)!=\r\n              HAL_OK) {\r\n            Error_Handler();\r\n          }\r\n        }\r\n      }\r\n\r\n      if (xusiming_DW.DiscreteTimeIntegrator1_SYSTEM_ENABLE != 0) {\r\n        xusiming_B.DiscreteTimeIntegrator1 =\r\n          xusiming_DW.DiscreteTimeIntegrator1_DSTATE;\r\n      } else {\r\n        xusiming_B.DiscreteTimeIntegrator1 = 0.001 * (real_T)Subsystem1_ELAPS_T *\r\n          xusiming_DW.DiscreteTimeIntegrator1_PREV_U +\r\n          xusiming_DW.DiscreteTimeIntegrator1_DSTATE;\r\n      }\r\n\r\n      DiscreteTimeIntegrator = floor(10.0 * xusiming_DW.ki);\r\n      if (rtIsNaN(DiscreteTimeIntegrator) || rtIsInf(DiscreteTimeIntegrator)) {\r\n        DiscreteTimeIntegrator = 0.0;\r\n      } else {\r\n        DiscreteTimeIntegrator = fmod(DiscreteTimeIntegrator, 256.0);\r\n      }\r\n\r\n      xusiming_B.DataTypeConversion = (uint8_T)(DiscreteTimeIntegrator < 0.0 ?\r\n        (int32_T)(uint8_T)-(int8_T)(uint8_T)-DiscreteTimeIntegrator : (int32_T)\r\n        (uint8_T)DiscreteTimeIntegrator);\r\n      DiscreteTimeIntegrator = floor(10.0 * xusiming_DW.kp);\r\n      if (rtIsNaN(DiscreteTimeIntegrator) || rtIsInf(DiscreteTimeIntegrator)) {\r\n        DiscreteTimeIntegrator = 0.0;\r\n      } else {\r\n        DiscreteTimeIntegrator = fmod(DiscreteTimeIntegrator, 256.0);\r\n      }\r\n\r\n      xusiming_B.DataTypeConversion1 = (uint8_T)(DiscreteTimeIntegrator < 0.0 ?\r\n        (int32_T)(uint8_T)-(int8_T)(uint8_T)-DiscreteTimeIntegrator : (int32_T)\r\n        (uint8_T)DiscreteTimeIntegrator);\r\n      DiscreteTimeIntegrator = floor(xusiming_DW.execpt);\r\n      if (rtIsNaN(DiscreteTimeIntegrator) || rtIsInf(DiscreteTimeIntegrator)) {\r\n        DiscreteTimeIntegrator = 0.0;\r\n      } else {\r\n        DiscreteTimeIntegrator = fmod(DiscreteTimeIntegrator, 256.0);\r\n      }\r\n\r\n      xusiming_B.DataTypeConversion3 = (uint8_T)(DiscreteTimeIntegrator < 0.0 ?\r\n        (int32_T)(uint8_T)-(int8_T)(uint8_T)-DiscreteTimeIntegrator : (int32_T)\r\n        (uint8_T)DiscreteTimeIntegrator);\r\n      if (xusiming_DW.DiscreteTimeIntegrator_SYSTEM_ENABLE != 0) {\r\n        DiscreteTimeIntegrator = xusiming_DW.DiscreteTimeIntegrator_DSTATE;\r\n      } else {\r\n        DiscreteTimeIntegrator = 0.001 * (real_T)Subsystem1_ELAPS_T\r\n          * xusiming_DW.DiscreteTimeIntegrator_PREV_U +\r\n          xusiming_DW.DiscreteTimeIntegrator_DSTATE;\r\n      }\r\n\r\n      rtb_Sum1 = xusiming_DW.execpt - (real_T)\r\n        xusiming_B.TmpRTBAtSubsystem2Outport1;\r\n      rtb_Product = xusiming_DW.ki * rtb_Sum1;\r\n      rtb_Product1 = (rtb_Sum1 - xusiming_DW.Delay1_DSTATE) * xusiming_DW.kp;\r\n\r\n      {\r\n        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_6);\r\n      }\r\n\r\n      xusiming_DW.DiscreteTimeIntegrator1_SYSTEM_ENABLE = 0U;\r\n      xusiming_DW.DiscreteTimeIntegrator1_DSTATE =\r\n        xusiming_B.DiscreteTimeIntegrator1;\r\n      xusiming_DW.DiscreteTimeIntegrator1_PREV_U = (0.0 * DiscreteTimeIntegrator\r\n        + rtb_Product) + rtb_Product1;\r\n\r\n      {\r\n        if (xusiming_B.DiscreteTimeIntegrator1 != TIM1_Conf.CH4_duty) {\r\n          TIM1_Conf.CH4_duty = xusiming_B.DiscreteTimeIntegrator1;\r\n          if (xusiming_B.DiscreteTimeIntegrator1 >= 0) {\r\n            /* Channe4 duty cycle is an input port. */\r\n            __HAL_TIM_SET_COMPARE(&htim1,TIM_CHANNEL_4,(uint32_t)\r\n                                  (xusiming_B.DiscreteTimeIntegrator1 * (&htim1\r\n              )->Instance->ARR / 100));\r\n          }\r\n        }\r\n      }\r\n\r\n      xusiming_DW.Delay1_DSTATE = rtb_Sum1;\r\n      xusiming_DW.DiscreteTimeIntegrator_SYSTEM_ENABLE = 0U;\r\n      xusiming_DW.DiscreteTimeIntegrator_DSTATE = DiscreteTimeIntegrator;\r\n      xusiming_DW.DiscreteTimeIntegrator_PREV_U = rtb_Sum1;\r\n    }\r\n  }\r\n}\r\n\r\n/*******************************************************************************\r\n * Function Name  : TIM3_ItUpFcn\r\n * Description    : TIM3 update interrupt\r\n * Input          : None\r\n * TIM3_ItUpFcn is called from TIM_PeriodElapsedCustomCallback function\r\n * in xusiming_TIM.c file.\r\n *******************************************************************************/\r\nvoid TIM3_ItUpFcn()\r\n{\r\n  {\r\n    /* Output and update for function-call system: '<Root>/Subsystem2' */\r\n    {\r\n      uint8_T rtb_TmpSignalConversionAtSFunctionInport1[5];\r\n\r\n      /* Reset cpt request when Reset CNT is not 0. */\r\n      if (((uint16_T)0U) != 0 ) {\r\n        (&htim2)->Instance->CNT = 0;\r\n      }\r\n\r\n      xusiming_B.Timers1_o1 = (&htim2)->Instance->CNT;\r\n      xusiming_B.Timers1_o2 = __HAL_TIM_IS_TIM_COUNTING_DOWN(&htim2);\r\n      rtb_TmpSignalConversionAtSFunctionInport1[0] = 3U;\r\n      rtb_TmpSignalConversionAtSFunctionInport1[1] = 252U;\r\n      rtb_TmpSignalConversionAtSFunctionInport1[2] = xusiming_B.Timers1_o1;\r\n      rtb_TmpSignalConversionAtSFunctionInport1[3] = 252U;\r\n      rtb_TmpSignalConversionAtSFunctionInport1[4] = 3U;\r\n      xusiming_B.BuffPtr = getBuffPtr\r\n        (&rtb_TmpSignalConversionAtSFunctionInport1[0]);\r\n\r\n      {\r\n        if (((uint16_T)5U) != 0) {\r\n          /* Copy data to send. */\r\n          TX_CopyData(&USART2_TxConf, (uint8_t*)xusiming_B.BuffPtr, (uint16_t)\r\n                      ((uint16_T)5U));\r\n        }\r\n\r\n        if (USART2_TxConf.nb2Send) {\r\n          xusiming_B.USART_Send2 = 0;\r\n          USART2_TX_SendData(&USART2_TxConf);\r\n        }\r\n\r\n        if (USART2_TxConf.txStatus != SERIAL_TX_ON) {\r\n          xusiming_B.USART_Send2 = USART2_TxConf.nbSent;\r\n        }\r\n      }\r\n\r\n      /* Reset cpt request when Reset CNT is not 0. */\r\n      if (((uint16_T)1U) != 0 ) {\r\n        (&htim2)->Instance->CNT = 0;\r\n      }\r\n\r\n      xusiming_B.Timers2_o1 = (&htim2)->Instance->CNT;\r\n      xusiming_B.Timers2_o2 = __HAL_TIM_IS_TIM_COUNTING_DOWN(&htim2);\r\n\r\n      {\r\n      }\r\n\r\n      {\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] xusiming_TIM.c\r\n */\r\n"},{"name":"xusiming_TIM.h","type":"header","group":"","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Other files","code":"/*\r\n * File: xusiming_TIM.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_xusiming_TIM_h_\r\n#define RTW_HEADER_xusiming_TIM_h_\r\n#include \"STM32_Config.h\"\r\n\r\n/**\r\n * @brief TIM informations\r\n */\r\ntypedef struct {\r\n  uint32_t TIM_Prescaler;\r\n  uint32_t TIM_APBClock;\r\n  uint32_t TIM_ARR;\r\n  uint32_t TIM_Clock;\r\n  uint32_t TIM_Freq;\r\n  uint8_t CH1_type;\r\n  uint8_t CH2_type;\r\n  uint8_t CH3_type;\r\n  uint8_t CH4_type;\r\n  int32_t CH1_duty;\r\n  int32_t CH2_duty;\r\n  int32_t CH3_duty;\r\n  int32_t CH4_duty;\r\n\r\n  /* Input Capture data. */\r\n  uint32_t* ICCData;\r\n  uint32_t ICC1Capture;\r\n  uint32_t ICC1Freq;\r\n  uint32_t ICC1Duty;\r\n  uint32_t ICC2Capture;\r\n  uint32_t ICC2Freq;\r\n  uint32_t ICC2Duty;\r\n  uint32_t ICC3Capture;\r\n  uint32_t ICC3Freq;\r\n  uint32_t ICC3Duty;\r\n  uint32_t ICC4Capture;\r\n  uint32_t ICC4Freq;\r\n  uint32_t ICC4Duty;\r\n  uint16_t ICC1ReadValue1;\r\n  uint16_t ICC1ReadValue2;\r\n  uint16_t ICC1ReadValue3;\r\n  uint16_t ICC1ReadValue4;\r\n  uint16_t ICC2ReadValue1;\r\n  uint16_t ICC2ReadValue2;\r\n  uint16_t ICC2ReadValue3;\r\n  uint16_t ICC2ReadValue4;\r\n  uint16_t ICC3ReadValue1;\r\n  uint16_t ICC3ReadValue2;\r\n  uint16_t ICC3ReadValue3;\r\n  uint16_t ICC3ReadValue4;\r\n  uint16_t ICC4ReadValue1;\r\n  uint16_t ICC4ReadValue2;\r\n  uint16_t ICC4ReadValue3;\r\n  uint16_t ICC4ReadValue4;\r\n  uint8_t ICC1CaptureNumber;\r\n  uint8_t ICC2CaptureNumber;\r\n  uint8_t ICC3CaptureNumber;\r\n  uint8_t ICC4CaptureNumber;\r\n  void (* ItUpFcn)(void);\r\n  void (* ItTrgFcn)(void);\r\n  void (* ItComFcn)(void);\r\n  void (* ItBrkFcn)(void);\r\n  void (* ItCcFcn)(TIM_HandleTypeDef *htim);\r\n} TIM_ConfTypeDef;\r\n\r\ntypedef enum {\r\n  OUTPUT_COMP = 0,\r\n  OUTPUT_PWM,\r\n  OUTPUT_TRGO,\r\n  OUTPUT_FORCED,\r\n  INPUT_PWM,\r\n  INPUT_CAPTURE,\r\n  INPUT_ETR,\r\n  INPUT_ENCODER,\r\n  INPUT_HALL_SENSOR,\r\n  UNKNOWN\r\n} TIM_ChTypeDef;\r\n\r\n/* Number of configured TIMER. */\r\nextern uint16_t G_TIM_Count;\r\n\r\n/* Array of TIMER information. */\r\nextern TIM_ConfTypeDef* G_TIM_Conf[5];\r\nextern TIM_HandleTypeDef* G_TIM_Handler[5];\r\n\r\n/* TIM1 handler. */\r\nextern TIM_HandleTypeDef htim1;\r\n\r\n/* TIM1 informations. */\r\nextern TIM_ConfTypeDef TIM1_Conf;\r\n\r\n/* TIM2 handler. */\r\nextern TIM_HandleTypeDef htim2;\r\n\r\n/* TIM2 informations. */\r\nextern TIM_ConfTypeDef TIM2_Conf;\r\n\r\n/* TIM6 handler. */\r\nextern TIM_HandleTypeDef htim6;\r\n\r\n/* TIM6 informations. */\r\nextern TIM_ConfTypeDef TIM6_Conf;\r\n\r\n/* TIM6 polling timeout value. Number of Solver loop. (can be changed). */\r\nextern uint32_t G_TIM6_PollTimeOut;\r\n\r\n/* TIM3 handler. */\r\nextern TIM_HandleTypeDef htim3;\r\n\r\n/* TIM3 informations. */\r\nextern TIM_ConfTypeDef TIM3_Conf;\r\nextern void TIM6_ItUpFcn(void);\r\nextern void TIM3_ItUpFcn(void);\r\n\r\n#endif                                 /* RTW_HEADER_xusiming_TIM_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] xusiming_TIM.h\r\n */\r\n"},{"name":"xusiming_USART.c","type":"source","group":"","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Other files","code":"/*\r\n * File: xusiming_USART.c\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#include \"xusiming.h\"\r\n#include \"xusiming_USART.h\"\r\n#include \"main.h\"\r\n\r\n/* Number of USART/UART configured for send. */\r\nuint16_t G_SERIAL_TX_Count = 0;\r\n\r\n/* Array of USART/UART send data information. */\r\nSERIAL_TxConfTypeDef* G_SERIAL_TX_Conf[2];\r\nvoid* G_SERIAL_TX_Handler[2];\r\n\r\n/* USART2 ring data send buffer. */\r\nstatic uint8_t USART2_TxDataBuffer[256];\r\n\r\n/* USART2 send data structure information. */\r\nSERIAL_TxConfTypeDef USART2_TxConf;\r\n\r\n/*******************************************************************************\r\n * Function Name  : TX_CopyData\r\n * Description    : Copy msg to send to ring buffer (if possible)\r\n * Input          : pointer to data to send , length(number) of data to send and\r\n *                  ring buffer context\r\n *******************************************************************************/\r\nvoid TX_CopyData(struct SERIAL_TxConf* pConf, uint8_t* pSrc, uint16_t dataLength)\r\n{\r\n  uint16_t msgSize = 0;\r\n  uint16_t idx;\r\n\r\n  /* Copy msg to send to ring buffer */\r\n  for (idx = 0; idx < dataLength; idx++) {\r\n    if ((pConf->pTx_W == pConf->pTx_R) && (pConf->nb2Send!=0))\r\n      break;                           /* Ring Buffer is full. */\r\n    *pConf->pTx_W++ = *pSrc++;\r\n    msgSize++;\r\n    if (pConf->pTx_W == pConf->pTx_R)\r\n      break;                           /* Ring Buffer is full. */\r\n    if (pConf->pTx_W == pConf->pTx_BuffEnd) {\r\n      /* Revolve buffer. */\r\n      pConf->pTx_W = pConf->pTx_BuffStart;\r\n    }\r\n  }\r\n\r\n  /* Update number of data to send. */\r\n  /* Access locked. */\r\n  pConf->txLock = 1;\r\n  pConf->nb2Send += msgSize;\r\n\r\n  /* If end of send interrupt mode arrived during last instruction. */\r\n  if (pConf->txLock == 2)\r\n    pConf->nb2Send -= pConf->nbSent;\r\n\r\n  /* Unlock access. */\r\n  pConf->txLock = 0;\r\n  if (msgSize < dataLength)\r\n    pConf->nbMsgLost++;                /* Message not all sent. */\r\n}\r\n\r\n/**\r\n * @brief Tx Transfer completed callback.\r\n * @param huart UART handle.\r\n * @retval None\r\n */\r\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)\r\n{\r\n  SERIAL_TxConfTypeDef* pConf = G_SERIAL_TX_Conf[0];\r\n  UART_HandleTypeDef* pHandler = (UART_HandleTypeDef*)G_SERIAL_TX_Handler[0];\r\n\r\n  {\r\n    uint16_t idx = 0;\r\n    for (idx = 0;idx < 2;idx++) {\r\n      pHandler = (UART_HandleTypeDef*)G_SERIAL_TX_Handler[idx];\r\n      if (pHandler == huart) {\r\n        pConf = G_SERIAL_TX_Conf[idx];\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (pHandler == huart) {\r\n    pConf->txStatus = SERIAL_TX_OK;\r\n    pConf->pTx_R += pConf->nbSent;\r\n    if (pConf->pTx_R >= pConf->pTx_BuffEnd) {\r\n      pConf->pTx_R = pConf->pTx_BuffStart;\r\n    }\r\n\r\n    if (pConf->txLock == 0) {\r\n      pConf->nb2Send -= pConf->nbSent;\r\n    } else {\r\n      pConf->txLock = 2;\r\n    }\r\n  }\r\n}\r\n\r\n/*******************************************************************************\r\n * Function Name  : USART2_TX_SendData\r\n * Description    : Send ring buffer management\r\n * Input          : Ring buffer context\r\n *******************************************************************************/\r\nvoid USART2_TX_SendData(struct SERIAL_TxConf* pConf)\r\n{\r\n  uint16_t msgSize;\r\n\r\n  /* If USART is not already running and data to send */\r\n  if ((pConf->txStatus != SERIAL_TX_ON) && pConf->nb2Send) {\r\n    pConf->txStatus = SERIAL_TX_ON;\r\n    msgSize = (uint32_t)pConf->pTx_BuffEnd - (uint32_t)pConf->pTx_R;\r\n\r\n    /* Send all msg or end of ring buffer */\r\n    if (pConf->nb2Send <= msgSize) {\r\n      pConf->nbSent = pConf->nb2Send;\r\n\r\n      /* USART2 interrupt send mode*/\r\n      HAL_UART_Transmit_IT(&huart2, pConf->pTx_R, pConf->nb2Send);\r\n    } else {\r\n      pConf->nbSent = msgSize;\r\n\r\n      /* USART2 interrupt send mode*/\r\n      HAL_UART_Transmit_IT(&huart2, pConf->pTx_R, msgSize);\r\n    }\r\n  }\r\n}\r\n\r\n/*******************************************************************************\r\n * Function Name  : USART2_Tx_Initialization\r\n * Description    : Send Initialization of USART2\r\n * Input          : -\r\n *******************************************************************************/\r\nvoid USART2_Tx_Initialization(void)\r\n{\r\n  /* Store USART2 send configuration and its handler. */\r\n\r\n  /* Initialize ring buffer information. */\r\n  USART2_TxConf.nb2Send = 0;\r\n  USART2_TxConf.nbSent = 0;\r\n  USART2_TxConf.nbMsgLost = 0;\r\n  USART2_TxConf.buffSize = 256;\r\n  USART2_TxConf.pTx_BuffStart = &USART2_TxDataBuffer[0];\r\n  USART2_TxConf.pTx_BuffEnd = &USART2_TxDataBuffer[256];\r\n  USART2_TxConf.pTx_W = USART2_TxDataBuffer;\r\n  USART2_TxConf.pTx_R = USART2_TxDataBuffer;\r\n  USART2_TxConf.CopyData = TX_CopyData;\r\n  USART2_TxConf.SendData = USART2_TX_SendData;\r\n  USART2_TxConf.txStatus = SERIAL_TX_OFF;\r\n  USART2_TxConf.txLock = 0;\r\n\r\n  /* Register this USART2 in global configuration stores. */\r\n  G_SERIAL_TX_Conf[G_SERIAL_TX_Count] = &USART2_TxConf;\r\n  G_SERIAL_TX_Handler[G_SERIAL_TX_Count] = (void*)&huart2;\r\n  G_SERIAL_TX_Count++;\r\n}\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] xusiming_USART.c\r\n */\r\n"},{"name":"xusiming_USART.h","type":"header","group":"","path":"C:\\Users\\Administrator\\Desktop\\bishe\\xusiming_stm32","tag":"","groupDisplay":"Other files","code":"/*\r\n * File: xusiming_USART.h\r\n *\r\n * Code generated for Simulink model :xusiming.\r\n *\r\n * Model version      : 1.48\r\n * Simulink Coder version    : 9.7 (R2022a) 13-Nov-2021\r\n * TLC version       : 9.7 (Feb 17 2022)\r\n * C/C++ source code generated on  : Thu Apr 25 14:58:01 2024\r\n *\r\n * Target selection: stm32.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n *\r\n *\r\n * ******************************************************************************\r\n * * attention\r\n * *\r\n * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\r\n * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\r\n * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\r\n * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\r\n * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\r\n * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\r\n * *\r\n * ******************************************************************************\r\n */\r\n\r\n#ifndef RTW_HEADER_xusiming_USART_h_\r\n#define RTW_HEADER_xusiming_USART_h_\r\n#include \"STM32_Config.h\"\r\n\r\n/* USART2_Tx_Initialization declaration. */\r\nvoid USART2_Tx_Initialization(void);\r\n\r\n/**\r\n * @brief USART Tx State structures definition\r\n */\r\ntypedef enum {\r\n  SERIAL_TX_ON = 0x00,                 /*!< Tx serial communication started. */\r\n  SERIAL_TX_OK = 0x01,               /*!< Tx serial communication terminated. */\r\n  SERIAL_TX_OFF = 0x02                 /*!< Tx serial communication stopped. */\r\n} SERIAL_TxStatusTypeDef;\r\n\r\n/**\r\n * @brief SERIAL data information\r\n */\r\ntypedef struct SERIAL_TxConf {\r\n  uint16_t nb2Send;                    /*!< Nb of char to send*/\r\n  uint16_t nbSent;                     /*!< Nb sent char*/\r\n  uint16_t nbMsgLost;       /*!< Nb lost msg (not enough space in ring buffer)*/\r\n  uint16_t buffSize;                   /*!< Size of send ring buffer*/\r\n  uint8_t* pTx_BuffStart;              /*!< point to ring buffer*/\r\n  uint8_t* pTx_BuffEnd;                /*!< point to end ring buffer*/\r\n  uint8_t* pTx_W;                      /*!< point to free space*/\r\n  uint8_t* pTx_R;                      /*!< point to char to send*/\r\n  void (* CopyData)(struct SERIAL_TxConf* pConf, uint8_t* pSrc, uint16_t\r\n                    dataLength);\r\n  void (* SendData)(struct SERIAL_TxConf* pConf);\r\n  __IO SERIAL_TxStatusTypeDef txStatus;/*!< Usart send communication status.*/\r\n  __IO uint8_t txLock;                 /*!< lock data access */\r\n} SERIAL_TxConfTypeDef;\r\n\r\n/* USART2 HAL handler. */\r\nextern UART_HandleTypeDef huart2;\r\n\r\n/* USART2 send configuration. */\r\nextern SERIAL_TxConfTypeDef USART2_TxConf;\r\nvoid TX_CopyData(struct SERIAL_TxConf*, uint8_t*, uint16_t);\r\n\r\n/* USART2_TX_SendData declaration. */\r\nvoid USART2_TX_SendData(struct SERIAL_TxConf*);\r\n\r\n#endif                                 /* RTW_HEADER_xusiming_USART_h_ */\r\n\r\n/* File trailer for Real-Time Workshop generated code.\r\n *\r\n * [EOF] xusiming_USART.h\r\n */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};